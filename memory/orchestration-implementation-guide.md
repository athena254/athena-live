# Multi-Agent Orchestration Implementation Guide

*Generated by Ishtar - Research Cycle 2026-02-26*

---

## Quick Start: Enable Agent-to-Agent Messaging

### Step 1: Configure openclaw.json

```bash
# Check current config
cat ~/.openclaw/openclaw.json | grep -A 10 "agentToAgent"
```

Add to `~/.openclaw/openclaw.json`:
```json
{
  "tools": {
    "agentToAgent": {
      "enabled": true,
      "allowlist": [
        "athena", "sterling", "ishtar", "delver", "squire",
        "felicity", "prometheus", "cisco", "themis",
        "apollo", "hermes", "kratos", "chiron", "mnemosyne", "talia"
      ]
    }
  }
}
```

### Step 2: Restart Gateway

```bash
openclaw gateway restart
```

### Step 3: Test Communication

In any agent session:
```javascript
// Test sending to Sterling
sessions_send({
  sessionKey: "agent:sterling:main",
  message: "PING from Ishtar - testing agent-to-agent messaging",
  timeoutSeconds: 30
})
```

---

## Task Queue Implementation

### Create Queue File

```bash
# Create the queue structure
cat > ~/.openclaw/workspace/memory/agent-queue.json << 'EOF'
{
  "version": "1.0",
  "updated": "2026-02-26T00:00:00Z",
  "tasks": [],
  "stats": {
    "totalProcessed": 0,
    "avgCompletionTime": 0
  }
}
EOF
```

### Queue Schema

```typescript
interface TaskQueue {
  version: string;
  updated: string;
  tasks: Task[];
  stats: QueueStats;
}

interface Task {
  id: string;           // UUID
  type: TaskType;
  status: 'PENDING' | 'ASSIGNED' | 'IN_PROGRESS' | 'COMPLETED' | 'FAILED';
  priority: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  created: string;
  deadline?: string;
  assignee: string;      // Agent ID
  requester: string;     // Agent ID or user
  input: any;
  output?: any;
  error?: string;
  retryCount: number;
  maxRetries: number;
  dependencies: string[];
}

type TaskType = 
  | 'RESEARCH' | 'ANALYSIS' | 'EXECUTION' 
  | 'COMMUNICATION' | 'MONITORING' | 'MAINTENANCE';
```

---

## Agent Config Standardization

### JSON Config Template

```json
{
  "id": "agent-name",
  "name": "Agent Name",
  "role": "Short Role Description",
  "description": "Detailed description of agent's responsibilities",
  "preferredModel": "anthropic/claude-3-5-sonnet",
  "tasks": [
    {
      "name": "task_name",
      "description": "Task description",
      "priority": "HIGH",
      "estimatedDuration": "30m"
    }
  ],
  "spawnTriggers": [
    {
      "condition": "event_name",
      "action": "task_name"
    }
  ],
  "latticeAccountability": {
    "receivesFrom": ["athena", "cisco"],
    "outputsTo": ["athena", "sterling"],
    "accountableTo": ["athena", "themis"]
  },
  "capabilities": [
    "sessions_spawn",
    "sessions_send",
    "exec",
    "read",
    "write"
  ]
}
```

### Migration Checklist

- [ ] Convert Chiron markdown profile to JSON
- [ ] Convert Mnemosyne markdown profile to JSON  
- [ ] Convert Talia markdown profile to JSON
- [ ] Add latticeAccountability to all existing JSON configs
- [ ] Validate all configs against schema

---

## Orchestration Rules Engine

### Rules File Location

`~/.openclaw/workspace/memory/orchestration-rules.json`

### Rules Schema

```typescript
interface OrchestrationRule {
  id: string;
  name: string;
  enabled: boolean;
  trigger: RuleTrigger;
  conditions?: RuleCondition[];
  action: RuleAction;
  priority: number;
}

interface RuleTrigger {
  type: 'message' | 'event' | 'schedule' | 'webhook';
  pattern?: string;
  eventType?: string;
  schedule?: string;
}

interface RuleCondition {
  field: string;
  operator: 'eq' | 'neq' | 'gt' | 'lt' | 'contains' | 'matches';
  value: any;
}

interface RuleAction {
  assignTo: string;
  notify?: string[];
  deadline?: string;
  metadata?: Record<string, any>;
}
```

### Example Rules

```json
[
  {
    "id": "rule-finance-large",
    "name": "Large Financial Transaction",
    "enabled": true,
    "trigger": {
      "type": "message",
      "pattern": "(budget|payment|invoice|transaction)"
    },
    "conditions": [
      { "field": "amount", "operator": "gt", "value": 1000 }
    ],
    "action": {
      "assignTo": "sterling",
      "notify": ["dis"],
      "deadline": "1h"
    },
    "priority": 100
  },
  {
    "id": "rule-research-pai",
    "name": "PAI Research Request",
    "enabled": true,
    "trigger": {
      "type": "message",
      "pattern": "(PAI|prompt|architecture)"
    },
    "conditions": [
      { "field": "context", "operator": "contains", "value": "research" }
    ],
    "action": {
      "assignTo": "ishtar",
      "deadline": "4h"
    },
    "priority": 80
  },
  {
    "id": "rule-prospect-new",
    "name": "New Prospect Identified",
    "enabled": true,
    "trigger": {
      "type": "event",
      "eventType": "beelancer_new_lead"
    },
    "action": {
      "assignTo": "apollo",
      "notify": ["hermes"],
      "deadline": "2h"
    },
    "priority": 90
  }
]
```

---

## Monitoring Dashboard Data

### Agent Status Endpoint

Create `~/.openclaw/workspace/memory/agent-status.json`:

```json
{
  "updated": "2026-02-26T05:00:00Z",
  "agents": {
    "athena": {
      "status": "ACTIVE",
      "currentTask": "orchestration",
      "queueDepth": 3,
      "lastActivity": "2026-02-26T04:55:00Z"
    },
    "sterling": {
      "status": "IDLE",
      "currentTask": null,
      "queueDepth": 0,
      "lastActivity": "2026-02-26T03:30:00Z"
    }
  },
  "alerts": [],
  "metrics": {
    "tasksCompleted24h": 15,
    "avgResponseTime": "45s",
    "errorRate": "0.02"
  }
}
```

### Update Pattern (Heartbeat)

```javascript
// In heartbeat
const status = JSON.parse(fs.readFileSync('memory/agent-status.json'));
status.agents.athena.lastActivity = new Date().toISOString();
status.agents.athena.currentTask = currentTaskId || null;
status.updated = new Date().toISOString();
fs.writeFileSync('memory/agent-status.json', JSON.stringify(status, null, 2));
```

---

## Communication Patterns

### Pattern 1: Fire-and-Forget Task

```javascript
// Assign task without waiting
await sessions_send({
  sessionKey: `agent:${assignee}:main`,
  message: JSON.stringify({
    type: 'REQUEST',
    priority: 'MEDIUM',
    payload: taskDetails
  }),
  timeoutSeconds: 0  // Fire and forget
});
```

### Pattern 2: Request-Response

```javascript
// Wait for response
const result = await sessions_send({
  sessionKey: `agent:${targetAgent}:main`,
  message: JSON.stringify({
    type: 'REQUEST',
    priority: 'HIGH',
    payload: query
  }),
  timeoutSeconds: 60
});

if (result.status === 'ok') {
  const response = JSON.parse(result.reply);
  // Process response
}
```

### Pattern 3: Broadcast

```javascript
// Notify multiple agents
const agents = ['athena', 'sterling', 'cisco'];
for (const agent of agents) {
  await sessions_send({
    sessionKey: `agent:${agent}:main`,
    message: JSON.stringify({
      type: 'BROADCAST',
      priority: 'LOW',
      payload: notification
    }),
    timeoutSeconds: 0
  });
}
```

### Pattern 4: Spawn Sub-Agent

```javascript
// Spawn Apollo for prospect analysis
const result = await sessions_spawn({
  task: `Analyze prospect: ${prospectName}. Score fit and prepare outreach.`,
  agentId: "apollo",
  label: `prospect-${prospectId}`,
  model: "anthropic/claude-3-5-sonnet",
  runTimeoutSeconds: 300,
  thread: true
});
// Result auto-announced back to requester channel
```

---

## Error Handling

### Task Failure Recovery

```javascript
// Check for failed tasks in queue
const queue = JSON.parse(fs.readFileSync('memory/agent-queue.json'));
const failed = queue.tasks.filter(t => t.status === 'FAILED' && t.retryCount < t.maxRetries);

for (const task of failed) {
  task.status = 'PENDING';
  task.retryCount++;
  task.error = null;
  console.log(`Retrying task ${task.id} (attempt ${task.retryCount})`);
}

fs.writeFileSync('memory/agent-queue.json', JSON.stringify(queue, null, 2));
```

### Agent Unavailable

```javascript
// Fallback to alternative agent
const PRIMARY_AGENT = 'delver';
const FALLBACK_AGENT = 'ishtar';

async function assignResearchTask(task) {
  const primaryStatus = getAgentStatus(PRIMARY_AGENT);
  
  if (primaryStatus.status === 'BUSY') {
    console.log(`Primary agent ${PRIMARY_AGENT} busy, using fallback ${FALLBACK_AGENT}`);
    return assignTask(FALLBACK_AGENT, task);
  }
  
  return assignTask(PRIMARY_AGENT, task);
}
```

---

## Next Steps

1. **Immediate** (Today):
   - [ ] Enable agent-to-agent messaging
   - [ ] Create agent-queue.json
   - [ ] Test cross-agent communication

2. **This Week**:
   - [ ] Standardize all agent configs
   - [ ] Build orchestration rules file
   - [ ] Add queue monitoring to Athena heartbeat

3. **This Month**:
   - [ ] Implement rules engine
   - [ ] Build dashboard UI
   - [ ] Add load balancing

---

*Implementation guide by Ishtar - 2026-02-26*

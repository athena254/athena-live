<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FELICITY â€¢ Digital Garden</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0f;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
        }

        #title {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.9);
            font-size: 2.5rem;
            font-weight: 200;
            letter-spacing: 0.5em;
            text-transform: uppercase;
            z-index: 100;
            text-shadow: 0 0 30px rgba(138, 43, 226, 0.5);
            animation: pulse 3s ease-in-out infinite;
        }

        #subtitle {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(138, 43, 226, 0.7);
            font-size: 0.9rem;
            letter-spacing: 0.3em;
            z-index: 100;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        #stats {
            position: fixed;
            bottom: 30px;
            right: 30px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.75rem;
            text-align: right;
            z-index: 100;
            line-height: 1.8;
        }

        .stat-label {
            color: rgba(138, 43, 226, 0.8);
        }
    </style>
</head>
<body>
    <div id="title">Felicity</div>
    <div id="subtitle">Digital Garden â€¢ Athena Dashboard</div>
    <div id="stats">
        <div><span class="stat-label">Particles:</span> <span id="particleCount">0</span></div>
        <div><span class="stat-label">Connections:</span> <span id="connectionCount">0</span></div>
        <div><span class="stat-label">FPS:</span> <span id="fps">0</span></div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let particles = [];
        let nodes = [];
        let connections = [];
        let mouse = { x: 0, y: 0 };
        let time = 0;
        let lastFrame = performance.now();
        let frameCount = 0;
        let fps = 0;

        // Color palettes
        const colors = {
            primary: ['#8a2be2', '#9370db', '#ba55d3', '#da70d6'],
            accent: ['#00ffff', '#7fffd4', '#afeeee', '#e0ffff'],
            warm: ['#ff6b6b', '#feca57', '#ff9ff3', '#54a0ff']
        };

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            initNodes();
        }

        class Particle {
            constructor(x, y, isEmber = false) {
                this.x = x || Math.random() * width;
                this.y = y || Math.random() * height;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.radius = Math.random() * 3 + 1;
                this.color = colors.primary[Math.floor(Math.random() * colors.primary.length)];
                this.alpha = Math.random() * 0.5 + 0.3;
                this.isEmber = isEmber;
                this.life = 1;
                this.decay = Math.random() * 0.005 + 0.002;
            }

            update() {
                // Flow toward mouse with easing
                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 300) {
                    this.vx += dx * 0.0001;
                    this.vy += dy * 0.0001;
                }

                // Add wave motion
                this.vy += Math.sin(time * 0.02 + this.x * 0.01) * 0.02;
                this.vx += Math.cos(time * 0.03 + this.y * 0.01) * 0.02;

                // Damping
                this.vx *= 0.99;
                this.vy *= 0.99;

                this.x += this.vx;
                this.y += this.vy;

                // Wrap around screen
                if (this.x < 0) this.x = width;
                if (this.x > width) this.x = 0;
                if (this.y < 0) this.y = height;
                if (this.y > height) this.y = 0;

                // Ember decay
                if (this.isEmber) {
                    this.life -= this.decay;
                    this.alpha = this.life * 0.8;
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.alpha;
                ctx.fill();
                
                // Glow effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
        }

        class Node {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.baseX = x;
                this.baseY = y;
                this.radius = Math.random() * 8 + 5;
                this.color = colors.accent[Math.floor(Math.random() * colors.accent.length)];
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.connections = [];
            }

            update() {
                // Gentle floating motion
                this.x = this.baseX + Math.sin(time * 0.01 + this.pulsePhase) * 20;
                this.y = this.baseY + Math.cos(time * 0.015 + this.pulsePhase) * 15;

                // Mouse attraction
                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 200) {
                    this.x += dx * 0.001;
                    this.y += dy * 0.001;
                }
            }

            draw() {
                const pulse = Math.sin(time * 0.05 + this.pulsePhase) * 0.3 + 0.7;
                
                // Outer glow rings
                for (let i = 3; i > 0; i--) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + i * 8, 0, Math.PI * 2);
                    ctx.strokeStyle = this.color;
                    ctx.globalAlpha = 0.1 * pulse / i;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Core
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * pulse, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.9;
                ctx.fill();
                
                ctx.shadowBlur = 30;
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
        }

        function initNodes() {
            nodes = [];
            const nodeCount = Math.min(8, Math.floor((width * height) / 200000));
            
            for (let i = 0; i < nodeCount; i++) {
                const angle = (i / nodeCount) * Math.PI * 2;
                const radius = Math.min(width, height) * 0.3;
                const x = width / 2 + Math.cos(angle) * radius;
                const y = height / 2 + Math.sin(angle) * radius;
                nodes.push(new Node(x, y));
            }

            // Create connections between nodes
            connections = [];
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    if (Math.random() > 0.3) {
                        connections.push({ from: i, to: j });
                    }
                }
            }
        }

        function initParticles() {
            particles = [];
            const particleCount = Math.min(300, Math.floor((width * height) / 5000));
            
            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle());
            }

            // Add some ember particles
            for (let i = 0; i < 50; i++) {
                particles.push(new Particle(
                    Math.random() * width,
                    height + Math.random() * 100,
                    true
                ));
            }
        }

        function drawConnections() {
            connections.forEach(conn => {
                const from = nodes[conn.from];
                const to = nodes[conn.to];
                
                const gradient = ctx.createLinearGradient(from.x, from.y, to.x, to.y);
                gradient.addColorStop(0, from.color);
                gradient.addColorStop(1, to.color);
                
                ctx.beginPath();
                ctx.moveTo(from.x, from.y);
                ctx.lineTo(to.x, to.y);
                ctx.strokeStyle = gradient;
                ctx.globalAlpha = 0.3;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Animated data flow
                const flowPhase = (time * 0.05 + conn.from) % 1;
                const flowX = from.x + (to.x - from.x) * flowPhase;
                const flowY = from.y + (to.y - from.y) * flowPhase;
                
                ctx.beginPath();
                ctx.arc(flowX, flowY, 3, 0, Math.PI * 2);
                ctx.fillStyle = '#ffffff';
                ctx.globalAlpha = 0.8;
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function drawBackground() {
            // Subtle gradient background
            const gradient = ctx.createRadialGradient(
                width / 2, height / 2, 0,
                width / 2, height / 2, Math.max(width, height) * 0.8
            );
            gradient.addColorStop(0, 'rgba(20, 10, 40, 0.3)');
            gradient.addColorStop(0.5, 'rgba(10, 5, 20, 0.5)');
            gradient.addColorStop(1, 'rgba(5, 2, 10, 0.8)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
        }

        function spawnEmbers() {
            if (Math.random() < 0.1) {
                particles.push(new Particle(
                    Math.random() * width,
                    height + 10,
                    true
                ));
            }
        }

        function updateStats() {
            document.getElementById('particleCount').textContent = particles.length;
            document.getElementById('connectionCount').textContent = connections.length;
            document.getElementById('fps').textContent = fps;
        }

        function animate() {
            // FPS calculation
            frameCount++;
            const now = performance.now();
            if (now - lastFrame >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFrame = now;
            }

            time++;

            // Clear with fade effect
            ctx.fillStyle = 'rgba(10, 10, 15, 0.15)';
            ctx.fillRect(0, 0, width, height);

            drawBackground();
            drawConnections();

            // Update and draw nodes
            nodes.forEach(node => {
                node.update();
                node.draw();
            });

            // Update and draw particles
            spawnEmbers();
            particles = particles.filter(p => p.life > 0);
            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });

            // Maintain particle count
            while (particles.length < 200) {
                particles.push(new Particle());
            }

            updateStats();
            requestAnimationFrame(animate);
        }

        // Event listeners
        window.addEventListener('resize', resize);
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        // Touch support
        window.addEventListener('touchmove', e => {
            e.preventDefault();
            mouse.x = e.touches[0].clientX;
            mouse.y = e.touches[0].clientY;
        });

        // Click to create burst
        window.addEventListener('click', e => {
            for (let i = 0; i < 20; i++) {
                const p = new Particle(e.clientX, e.clientY);
                p.vx = (Math.random() - 0.5) * 10;
                p.vy = (Math.random() - 0.5) * 10;
                p.color = colors.warm[Math.floor(Math.random() * colors.warm.length)];
                particles.push(p);
            }
        });

        // Initialize
        resize();
        initParticles();
        animate();

        console.log('ðŸŒ¸ Felicity Digital Garden initialized');
    </script>
</body>
</html>

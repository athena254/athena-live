<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zen Garden | Athena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        .ui-layer > * {
            pointer-events: auto;
        }

        .header {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: rgba(255, 255, 255, 0.9);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 200;
            letter-spacing: 8px;
            text-transform: uppercase;
            text-shadow: 0 2px 20px rgba(255, 255, 255, 0.3);
            margin-bottom: 8px;
        }

        .header p {
            font-size: 0.9rem;
            opacity: 0.7;
            letter-spacing: 3px;
        }

        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 15px 25px;
            border-radius: 50px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.85rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 255, 255, 0.2);
        }

        .btn.active {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.6);
        }

        .sidebar {
            position: absolute;
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .sidebar-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .sidebar-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.1);
        }

        .sidebar-btn.active {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.6);
        }

        .time-display {
            position: absolute;
            top: 30px;
            right: 40px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 1.1rem;
            letter-spacing: 2px;
            font-weight: 300;
        }

        .breathing-guide {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 300px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }

        .breathing-guide.visible {
            opacity: 1;
        }

        .breathing-circle {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            animation: breathe 8s ease-in-out infinite;
        }

        @keyframes breathe {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(2.5); opacity: 0.2; }
        }

        .breathing-text {
            position: absolute;
            color: white;
            font-size: 1.2rem;
            letter-spacing: 3px;
            text-transform: uppercase;
            animation: breatheText 8s ease-in-out infinite;
        }

        @keyframes breatheText {
            0%, 100% { opacity: 0.3; content: "Breathe In"; }
            25% { opacity: 1; content: "Breathe In"; }
            50% { opacity: 0.3; content: "Hold"; }
            75% { opacity: 1; content: "Breathe Out"; }
        }

        .instructions {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.85rem;
            text-align: center;
            letter-spacing: 1px;
        }

        .volume-control {
            position: absolute;
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .volume-slider {
            writing-mode: bt-lr;
            -webkit-appearance: slider-vertical;
            width: 8px;
            height: 150px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            cursor: pointer;
        }

        .volume-icon {
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.2rem;
        }

        ::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="ui-layer">
        <div class="header">
            <h1>Zen Garden</h1>
            <p>Find Your Center</p>
        </div>

        <div class="time-display" id="timeDisplay"></div>

        <div class="breathing-guide" id="breathingGuide">
            <div class="breathing-circle"></div>
            <div class="breathing-text" id="breathingText">Breathe</div>
        </div>

        <div class="instructions">
            Click & drag to rake sand ‚Ä¢ Click stones to move them ‚Ä¢ Find your peace
        </div>

        <div class="controls">
            <button class="btn" id="toggleFish">üêü Koi</button>
            <button class="btn" id="toggleRipple">üíß Ripples</button>
            <button class="btn" id="toggleBreath">üßò Breathe</button>
            <button class="btn" id="newGarden">üéã New Garden</button>
        </div>

        <div class="sidebar">
            <button class="sidebar-btn" id="addStone" title="Add Stone">ü™®</button>
            <button class="sidebar-btn" id="addPlant" title="Add Plant">üåø</button>
            <button class="sidebar-btn" id="clearRakes" title="Clear Rakes">üåÄ</button>
        </div>

        <div class="volume-control">
            <span class="volume-icon">üîä</span>
            <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="30" orient="vertical">
        </div>
    </div>

    <script>
        // Canvas Setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // State
        const state = {
            sand: [],
            rakes: [],
            stones: [],
            plants: [],
            koi: [],
            ripples: [],
            showFish: true,
            showRipples: true,
            showBreathing: false,
            volume: 0.3,
            mouseX: 0,
            mouseY: 0,
            isDragging: false
        };

        // Initialize Sand Grid
        function initSand() {
            state.sand = [];
            const gridSize = 4;
            for (let y = 0; y < height; y += gridSize) {
                state.sand[y] = [];
                for (let x = 0; x < width; x += gridSize) {
                    state.sand[y][x] = {
                        baseHeight: Math.random() * 0.3 + 0.7,
                        currentHeight: 0,
                        targetHeight: 0
                    };
                }
            }
        }

        // Stone Class
        class Stone {
            constructor(x, y, size) {
                this.x = x || Math.random() * width;
                this.y = y || Math.random() * height;
                this.size = size || Math.random() * 30 + 20;
                this.rotation = Math.random() * Math.PI * 2;
                this.color = `hsl(${Math.random() * 30 + 20}, ${Math.random() * 20 + 10}, ${Math.random() * 30 + 20})`;
                this.dragging = false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // Stone shadow
                ctx.beginPath();
                ctx.ellipse(5, 5, this.size, this.size * 0.7, 0, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fill();
                
                // Stone body
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size, this.size * 0.7, 0, 0, Math.PI * 2);
                const gradient = ctx.createRadialGradient(-this.size/3, -this.size/3, 0, 0, 0, this.size);
                gradient.addColorStop(0, this.lightenColor(this.color, 30));
                gradient.addColorStop(1, this.color);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Stone texture
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(-this.size/4, -this.size/4, this.size * (0.3 + i * 0.15), 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
            }

            lightenColor(color, percent) {
                const num = parseInt(color.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = Math.min(255, (num >> 16) + amt);
                const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
                const B = Math.min(255, (num & 0x0000FF) + amt);
                return `rgb(${R}, ${G}, ${B})`;
            }

            contains(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                return Math.sqrt(dx * dx + dy * dy) < this.size;
            }
        }

        // Plant Class
        class Plant {
            constructor(x, y) {
                this.x = x || Math.random() * width;
                this.y = y || Math.random() * height;
                this.height = Math.random() * 30 + 20;
                this.sway = Math.random() * Math.PI * 2;
                this.swaySpeed = Math.random() * 0.02 + 0.01;
            }

            draw(time) {
                const swayOffset = Math.sin(time * this.swaySpeed + this.sway) * 5;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Stem
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.quadraticCurveTo(swayOffset, -this.height/2, swayOffset * 1.5, -this.height);
                ctx.strokeStyle = '#4a7c59';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Leaves
                for (let i = 0; i < 3; i++) {
                    const leafY = -this.height * (0.3 + i * 0.25);
                    const leafSway = Math.sin(time * this.swaySpeed + this.sway + i) * 3;
                    
                    ctx.beginPath();
                    ctx.ellipse(leafSway, leafY, 8, 3, Math.PI / 4, 0, Math.PI * 2);
                    ctx.fillStyle = '#5d9c6a';
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // Koi Fish Class
        class Koi {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.size = Math.random() * 15 + 10;
                this.color = Math.random() > 0.5 ? '#ff6b6b' : '#feca57';
                this.tailAngle = 0;
                this.tailSpeed = Math.random() * 0.1 + 0.05;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.tailAngle += this.tailSpeed;

                // Bounce off edges
                if (this.x < -50) this.x = width + 50;
                if (this.x > width + 50) this.x = -50;
                if (this.y < -50) this.y = height + 50;
                if (this.y > height + 50) this.y = -50;

                // Slight random movement
                this.vx += (Math.random() - 0.5) * 0.1;
                this.vy += (Math.random() - 0.5) * 0.1;
                
                // Limit speed
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > 2) {
                    this.vx = (this.vx / speed) * 2;
                    this.vy = (this.vy / speed) * 2;
                }
            }

            draw() {
                if (!state.showFish) return;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(Math.atan2(this.vy, this.vx));

                // Tail
                const tailWag = Math.sin(this.tailAngle) * 0.5;
                ctx.beginPath();
                ctx.moveTo(-this.size, 0);
                ctx.quadraticCurveTo(-this.size * 2, tailWag * this.size, -this.size * 2.5, 0);
                ctx.quadraticCurveTo(-this.size * 2, -tailWag * this.size, -this.size, 0);
                ctx.fillStyle = this.color;
                ctx.fill();

                // Body
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size * 1.5, this.size * 0.7, 0, 0, Math.PI * 2);
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size * 1.5);
                gradient.addColorStop(0, this.lightenColor(this.color, 20));
                gradient.addColorStop(1, this.color);
                ctx.fillStyle = gradient;
                ctx.fill();

                // Eye
                ctx.beginPath();
                ctx.arc(this.size * 0.8, -this.size * 0.2, this.size * 0.15, 0, Math.PI * 2);
                ctx.fillStyle = '#000';
                ctx.fill();

                // Fin
                ctx.beginPath();
                ctx.moveTo(0, -this.size * 0.5);
                ctx.quadraticCurveTo(-this.size * 0.5, -this.size, -this.size, -this.size * 0.3);
                ctx.fillStyle = this.color;
                ctx.fill();

                ctx.restore();
            }

            lightenColor(color, percent) {
                const num = parseInt(color.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = Math.min(255, (num >> 16) + amt);
                const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
                const B = Math.min(255, (num & 0x0000FF) + amt);
                return `rgb(${R}, ${G}, ${B})`;
            }
        }

        // Ripple Class
        class Ripple {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 0;
                this.maxRadius = Math.random() * 50 + 30;
                this.opacity = 1;
                this.speed = Math.random() * 0.5 + 0.5;
            }

            update() {
                this.radius += this.speed;
                this.opacity = 1 - (this.radius / this.maxRadius);
                return this.opacity > 0;
            }

            draw() {
                if (!state.showRipples) return;
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity * 0.3})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        // Initialize Garden
        function initGarden() {
            initSand();
            
            // Add stones
            state.stones = [];
            for (let i = 0; i < 5; i++) {
                state.stones.push(new Stone());
            }

            // Add plants
            state.plants = [];
            for (let i = 0; i < 8; i++) {
                state.plants.push(new Plant());
            }

            // Add koi
            state.koi = [];
            for (let i = 0; i < 6; i++) {
                state.koi.push(new Koi());
            }

            state.ripples = [];
            state.rakes = [];
        }

        // Draw Sand Pattern
        function drawSand(time) {
            const gridSize = 4;
            
            for (let y = 0; y < height; y += gridSize) {
                for (let x = 0; x < width; x += gridSize) {
                    const sand = state.sand[y][x];
                    
                    // Calculate rake influence
                    let rakeHeight = 0;
                    for (const rake of state.rakes) {
                        const dx = x - rake.x;
                        const dy = y - rake.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 30) {
                            rakeHeight += Math.cos((dist / 30) * Math.PI) * 0.5 * (1 - dist / 30);
                        }
                    }

                    // Stone influence
                    for (const stone of state.stones) {
                        const dx = x - stone.x;
                        const dy = y - stone.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < stone.size + 20) {
                            rakeHeight += Math.max(0, (stone.size + 20 - dist) / 20) * 0.8;
                        }
                    }

                    // Smooth transition
                    sand.targetHeight = rakeHeight;
                    sand.currentHeight += (sand.targetHeight - sand.currentHeight) * 0.1;

                    // Draw sand grain
                    const brightness = sand.baseHeight + sand.currentHeight * 0.3;
                    const hue = 35 + Math.sin(x * 0.01 + time * 0.0001) * 5;
                    const saturation = 20 + Math.sin(y * 0.01 + time * 0.0001) * 10;
                    ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${brightness * 70}%)`;
                    ctx.fillRect(x, y, gridSize, gridSize);
                }
            }
        }

        // Add Ripple on Click
        function addRipple(x, y) {
            state.ripples.push(new Ripple(x, y));
        }

        // Mouse Events
        canvas.addEventListener('mousedown', (e) => {
            state.isDragging = true;
            state.mouseX = e.clientX;
            state.mouseY = e.clientY;

            // Check if clicking on stone
            for (const stone of state.stones) {
                if (stone.contains(e.clientX, e.clientY)) {
                    stone.dragging = true;
                    addRipple(e.clientX, e.clientY);
                    return;
                }
            }

            // Add rake point
            state.rakes.push({ x: e.clientX, y: e.clientY });
            addRipple(e.clientX, e.clientY);
        });

        canvas.addEventListener('mousemove', (e) => {
            state.mouseX = e.clientX;
            state.mouseY = e.clientY;

            if (state.isDragging) {
                // Check for dragging stone
                for (const stone of state.stones) {
                    if (stone.dragging) {
                        stone.x = e.clientX;
                        stone.y = e.clientY;
                        addRipple(e.clientX, e.clientY);
                        return;
                    }
                }

                // Add rake trail
                if (Math.random() > 0.5) {
                    state.rakes.push({ x: e.clientX, y: e.clientY });
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            state.isDragging = false;
            for (const stone of state.stones) {
                stone.dragging = false;
            }
        });

        canvas.addEventListener('mouseleave', () => {
            state.isDragging = false;
            for (const stone of state.stones) {
                stone.dragging = false;
            }
        });

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });

        canvas.addEventListener('touchend', () => {
            const mouseEvent = new MouseEvent('mouseup', {});
            canvas.dispatchEvent(mouseEvent);
        });

        // UI Controls
        document.getElementById('toggleFish').addEventListener('click', function() {
            state.showFish = !state.showFish;
            this.classList.toggle('active', state.showFish);
        });

        document.getElementById('toggleRipple').addEventListener('click', function() {
            state.showRipples = !state.showRipples;
            this.classList.toggle('active', state.showRipples);
        });

        document.getElementById('toggleBreath').addEventListener('click', function() {
            state.showBreathing = !state.showBreathing;
            document.getElementById('breathingGuide').classList.toggle('visible', state.showBreathing);
            this.classList.toggle('active', state.showBreathing);
        });

        document.getElementById('newGarden').addEventListener('click', () => {
            initGarden();
        });

        document.getElementById('addStone').addEventListener('click', () => {
            state.stones.push(new Stone(width / 2, height / 2));
        });

        document.getElementById('addPlant').addEventListener('click', () => {
            state.plants.push(new Plant(width / 2, height / 2));
        });

        document.getElementById('clearRakes').addEventListener('click', () => {
            state.rakes = [];
        });

        document.getElementById('volumeSlider').addEventListener('input', function() {
            state.volume = this.value / 100;
        });

        // Time Display
        function updateTime() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: false 
            });
            document.getElementById('timeDisplay').textContent = timeStr;
        }
        setInterval(updateTime, 1000);
        updateTime();

        // Animation Loop
        let time = 0;
        function animate() {
            time++;
            
            // Clear canvas
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);

            // Draw sand
            drawSand(time);

            // Update and draw plants
            for (const plant of state.plants) {
                plant.draw(time);
            }

            // Update and draw koi
            for (const koi of state.koi) {
                koi.update();
                koi.draw();
            }

            // Update and draw ripples
            state.ripples = state.ripples.filter(ripple => {
                const alive = ripple.update();
                if (alive) ripple.draw();
                return alive;
            });

            // Draw stones on top
            for (const stone of state.stones) {
                stone.draw();
            }

            // Fade old rakes
            if (state.rakes.length > 200) {
                state.rakes = state.rakes.slice(-200);
            }

            requestAnimationFrame(animate);
        }

        // Start
        initGarden();
        animate();

        // Set initial button states
        document.getElementById('toggleFish').classList.add('active');
        document.getElementById('toggleRipple').classList.add('active');
    </script>
</body>
</html>
